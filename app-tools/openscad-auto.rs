#!/usr/bin/env -S cargo +nightly -Zscript --quiet --
---
[package]
edition = "2021"
[dependencies]
chrono = "0.4.38"
clap = { version = "4.5.20", features = ["derive"] }
clap_complete = "4.5.33"
hex = "0.4.3"
sha2 = "0.10.8"
shell-quote = "0.7.1"
---

// TODO: split out parts of this file into conveniences.

use chrono::Local;
use clap::{CommandFactory, Parser, ValueEnum};
use clap_complete::generator::generate;
use clap_complete::Shell;
use sha2::{Digest, Sha256};
use shell_quote::{Bash, QuoteRefExt};
use std::fs::{rename, File, OpenOptions};
use std::io::stdout;
use std::io::Write;
use std::io::{self, BufRead};
use std::path::Path;
use std::path::PathBuf;
use std::process::{exit, Command};

const BIN_NAME: &str = "openscad-auto"; // TODO: get this from `clap`

const LOW_FI_DEV_FALSE: &str = "LOW_FI_DEV = false;";
const ERROR_COULD_NOT_FIND_SOURCE_FILE: &str = "Could not open source file.";

#[derive(Parser, Debug)]
#[clap(version)]
struct Args {
    #[clap(verbatim_doc_comment, group="task")]
    source: Option<PathBuf>,

    #[clap(long, default_value = "3mf")]
    format: OutputFormat,

    #[clap(long, group="task", id = "SHELL")]
    completions: Option<Shell>,

    #[clap(long)]
    skip_low_fi_check: bool,
}

#[derive(Clone, Debug, ValueEnum)]
#[allow(non_camel_case_types)]
enum OutputFormat {
    #[clap(name = "stl")]
    stl,
    #[clap(name = "3mf")]
    _3mf,
}

impl OutputFormat {
    fn file_extension(&self) -> &str {
        match self {
            OutputFormat::stl => "stl",
            OutputFormat::_3mf => "3mf",
        }
    }
}

fn get_args() -> Args {
    // TODO: use the new `clap` built-in functionality.
    let mut command = Args::command();

    let args = Args::parse();
    if let Some(shell) = args.completions {
        generate(shell, &mut command, BIN_NAME, &mut stdout());
        exit(0);
    };

    args
}

fn main() {
    let args = get_args();
    let Some(source_file) = args.source else {
        Args::command().print_help().unwrap();
        exit(1);
    };

    // TODO: Tee the source `File` instead of reading multiple times?
    if !args.skip_low_fi_check && low_fi_guard(&source_file).is_err() {
        eprintln!("Could not verify that the file is set to hi-fi. Please make sure the following line is present:
{}", LOW_FI_DEV_FALSE);
        exit(1);
    }
    let sha256_hash = sha256(&source_file);

    let target_file_string = format!(
        "{}.{}",
        source_file.to_string_lossy(),
        args.format.file_extension()
    );
    let target_file = Path::new(&target_file_string);

    back_up_existing_file(target_file, args.format.file_extension());

    println!("✍️ Writing new file to: {}", target_file.to_string_lossy());

    let output = Command::new("openscad")
        .args([
            "--enable",
            "lazy-union",
            "--backend",
            "Manifold",
            "-o",
            &target_file.to_string_lossy(),
            &source_file.to_string_lossy(),
        ])
        .env("FONTCONFIG_PATH", "/opt/homebrew/etc/fonts")
        .output()
        .expect("Could not invoke `openscad`.");

    let mut total_rendering_time_string = Option::<String>::default();
    for line in output.stderr.lines().map_while(Result::ok) {
        eprintln!("{}", line);
        if line.starts_with("Total rendering time") {
            total_rendering_time_string = Some(
                line.splitn(2, ": ")
                    .last()
                    .expect("Could not determine total rendering time from output")
                    .to_owned(),
            );
        }
    }
    let Some(total_rendering_time_string) = total_rendering_time_string else {
        exit(1);
    };

    let mut file = OpenOptions::new()
        .append(true)
        .open(target_file)
        .expect("Could not access target file to add rendering comments.");

    // TODO: properly add this via 3MF metadata. In theory text comments are not part of the `.3mf` format, but they don't seem to mess anything up?
    writeln!(
        file,
        "\n/* Generated by `openscad-auto` on {} in {} from: {} (sha256: {}) */",
        Local::now().format("%Y-%m-%d"),
        total_rendering_time_string,
        source_file.to_string_lossy(),
        sha256_hash
    )
    .expect("Could not write comment to target file.");

    let quoted_target_file: String = (target_file.to_string_lossy()).quoted(Bash);
    Command::new("terminal-notifier")
        .args(vec![
            "-title",
            "openscad-auto",
            "-message",
            &format!(
                "⏭️ Done converting: {}
⏱️ Total rendering time: {}",
                source_file.to_string_lossy(),
                total_rendering_time_string
            ),
            "-execute",
            &format!("open -R {}", quoted_target_file),
        ])
        .spawn()
        .unwrap()
        .wait()
        .unwrap();
}

fn low_fi_guard(source: &Path) -> Result<(), ()> {
    for line in read_lines(source)
        .expect(ERROR_COULD_NOT_FIND_SOURCE_FILE)
        .map_while(Result::ok)
    {
        if line.starts_with(LOW_FI_DEV_FALSE) {
            return Ok(());
        };
    }
    Err(())
}

// The output is wrapped in a Result to allow matching on errors.
// Returns an Iterator to the Reader of the lines of the file.
fn read_lines<P>(filename: P) -> io::Result<io::Lines<io::BufReader<File>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    Ok(io::BufReader::new(file).lines())
}

fn sha256(source: &Path) -> String {
    let mut file = File::open(source).expect(ERROR_COULD_NOT_FIND_SOURCE_FILE);
    let mut hasher = Sha256::new();
    io::copy(&mut file, &mut hasher).expect("Could not hash source file.");
    let hash = hasher.finalize();
    hex::encode(hash)
}

fn back_up_existing_file(file: &Path, extension: &str) {
    if file.exists() {
        let date = Local::now().format("%Y-%m-%d_%H-%M-%S");
        let backup_file_name = format!("{}.back.{}.{}", file.to_string_lossy(), date, extension);
        println!(
            "➡️ Output file already exists. Moving to: {}",
            backup_file_name
        );
        rename(file, backup_file_name).expect("Could not back up existing target file.");
    }
}
